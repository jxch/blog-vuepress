[
  {
    "title": "Java 根据 Getter 方法获取字段及注解值",
    "path": "/blogs/bianmabiji/JavagenjuGetterfangfahuoquziduanjizhujiezhi.html",
    "url": "/blogs/bianmabiji/JavagenjuGetterfangfahuoquziduanjizhujiezhi.html",
    "content": "---\r\ntitle: Java 根据 Getter 方法获取字段及注解值\r\ndate: 2025/04/12\r\ntags:\r\n - Java\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface SIFunction<T, R> extends Function<T, R>, Serializable {}\r\n```\r\n\r\n```java\r\npublic class FieldUtil {\r\n\r\n    public static <T, R> String getFieldNameByGetter(SIFunction<T, R> func) {\r\n        try {\r\n            SerializedLambda serializedLambda = getSerializedLambda(func);\r\n            String getterMethodName = serializedLambda.getImplMethodName();\r\n            return methodToFieldName(getterMethodName);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"获取字段名失败\", e);\r\n        }\r\n    }\r\n\r\n    private static SerializedLambda getSerializedLambda(Serializable lambda) throws Exception {\r\n        // 通过反射调用writeReplace方法获取SerializedLambda\r\n        Method writeReplace = lambda.getClass().getDeclaredMethod(\"writeReplace\");\r\n        writeReplace.setAccessible(true);\r\n        return (SerializedLambda) writeReplace.invoke(lambda);\r\n    }\r\n\r\n    private static String methodToFieldName(String getterMethodName) {\r\n        String fieldName;\r\n        if (getterMethodName.startsWith(\"get\")) {\r\n            fieldName = getterMethodName.substring(3);\r\n        } else if (getterMethodName.startsWith(\"is\")) {\r\n            fieldName = getterMethodName.substring(2);\r\n        } else {\r\n            throw new IllegalArgumentException(\"无效的getter方法名称: \" + getterMethodName);\r\n        }\r\n        // 将首字母转小写\r\n        return fieldName.substring(0, 1).toLowerCase(Locale.ROOT) + fieldName.substring(1);\r\n    }\r\n\r\n    public static <T, R> Field getFieldByGetter(SIFunction<T, R> getter, Class<T> clazz) {\r\n        try {\r\n            return clazz.getDeclaredField(getFieldNameByGetter(getter));\r\n        } catch (NoSuchFieldException e) {\r\n            throw new RuntimeException(\"字段不存在\", e);\r\n        }\r\n    }\r\n\r\n    public static <T, R, A extends Annotation> String getAnnotationValueByGetter(SIFunction<T, R> getter, Class<T> clazz, Class<A> annotationClass) {\r\n        try {\r\n            // 获取字段名\r\n            String fieldName = getFieldNameByGetter(getter);\r\n\r\n            // 获取字段对象\r\n            Field field = clazz.getDeclaredField(fieldName);\r\n\r\n            // 获取字段上的注解\r\n            A annotation = field.getAnnotation(annotationClass);\r\n\r\n            // 如果注解存在，返回其 value 属性值\r\n            if (annotation != null) {\r\n                // 使用反射获取注解的 value 属性值\r\n                Method valueMethod = annotationClass.getMethod(\"value\");\r\n                return (String) valueMethod.invoke(annotation);\r\n            } else {\r\n                throw new RuntimeException(\"字段没有指定的注解: \" + fieldName);\r\n            }\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"获取注解值失败\", e);\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Java 根据 Getter 方法获取字段及注解值"
    },
    "frontmatter": {
      "title": "Java 根据 Getter 方法获取字段及注解值",
      "date": "2025/04/12",
      "tags": [
        "Java"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "Java 获取接口泛型类型",
    "path": "/blogs/bianmabiji/Javahuoqujiekoufanxingleixing.html",
    "url": "/blogs/bianmabiji/Javahuoqujiekoufanxingleixing.html",
    "content": "---\r\ntitle: Java 获取接口泛型类型\r\ndate: 2025/04/12\r\ntags:\r\n - Java\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n```java\r\n    @SuppressWarnings(\"unchecked\")\r\n    public Class<S> getTypeClass() {\r\n        Class<?> clazz = this.getClass();\r\n        Type result = InterfaceUtils.findParameterizedType(clazz, ProjectTypeServiceGetter.class);\r\n        if (result != null) {\r\n            ParameterizedType pt = (ParameterizedType) result;\r\n            // 获取第一个泛型参数，它对应 S\r\n            Type sType = pt.getActualTypeArguments()[0];\r\n            if (sType instanceof Class) {\r\n                return (Class<S>) sType;\r\n            } else if (sType instanceof ParameterizedType) {\r\n                // 处理嵌套泛型情况\r\n                return (Class<S>) ((ParameterizedType) sType).getRawType();\r\n            }\r\n        }\r\n        throw new IllegalStateException(\"无法获取泛型类型 S 的 Class 对象\");\r\n    }\r\n```\r\n\r\n\r\n```java\r\npublic class InterfaceUtils {\r\n\r\n    /**\r\n     * 获取指定类实现的所有接口，包括父类实现的接口以及接口之间的继承关系。\r\n     *\r\n     * @param clazz 要查找接口的类\r\n     * @return 包含所有接口的集合\r\n     */\r\n    public static Set<Class<?>> getAllInterfaces(Class<?> clazz) {\r\n        Set<Class<?>> interfaces = new HashSet<>();\r\n        // 遍历类的继承层次结构\r\n        while (clazz != null) {\r\n            // 获取当前类直接实现的接口\r\n            Class<?>[] directInterfaces = clazz.getInterfaces();\r\n            for (Class<?> intf : directInterfaces) {\r\n                collectInterfaces(intf, interfaces);\r\n            }\r\n            clazz = clazz.getSuperclass();\r\n        }\r\n        return interfaces;\r\n    }\r\n\r\n    /**\r\n     * 递归地将接口及其扩展的接口加入到集合中。\r\n     *\r\n     * @param intf       当前的接口\r\n     * @param interfaces 用来保存所有接口的集合\r\n     */\r\n    private static void collectInterfaces(Class<?> intf, Set<Class<?>> interfaces) {\r\n        if (interfaces.add(intf)) {\r\n            // 获取接口可能扩展的其他接口\r\n            for (Class<?> superInterface : intf.getInterfaces()) {\r\n                collectInterfaces(superInterface, interfaces);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static Type findParameterizedType(Type clazz, Class<?> targetType) {\r\n        if (clazz instanceof ParameterizedType) {\r\n            ParameterizedType pt = (ParameterizedType) clazz;\r\n            // 如果直接匹配目标接口\r\n            if (targetType.equals(pt.getRawType())) {\r\n                return pt;\r\n            }\r\n            // 检查该参数化类型的原始类型的接口\r\n            return findParameterizedType(pt.getRawType(), targetType);\r\n        } else if (clazz instanceof Class) {\r\n            Class<?> currentClass = (Class<?>) clazz;\r\n\r\n            // 检查当前类所有直接实现的接口\r\n            for (Type intf : currentClass.getGenericInterfaces()) {\r\n                Type result = findParameterizedType(intf, targetType);\r\n                if (result != null) {\r\n                    return result;\r\n                }\r\n            }\r\n            // 检查父类\r\n            Type superClass = currentClass.getGenericSuperclass();\r\n            if (superClass != null) {\r\n                return findParameterizedType(superClass, targetType);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n}\r\n```\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Java 获取接口泛型类型"
    },
    "frontmatter": {
      "title": "Java 获取接口泛型类型",
      "date": "2025/04/12",
      "tags": [
        "Java"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "MAVEN 上传到中心仓库",
    "path": "/blogs/bianmabiji/MAVENshangchuandaozhongxincangku.html",
    "url": "/blogs/bianmabiji/MAVENshangchuandaozhongxincangku.html",
    "content": "---\r\ntitle: MAVEN 上传到中心仓库\r\ndate: 2025/03/05\r\ntags:\r\n - MAVEN\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n::: tip\r\n1. 注册中心仓库账户：[central.sonatype.com](https://central.sonatype.com)\r\n2. 使用 GPG 生成密钥并上传到公钥服务器\r\n3. 配置 Maven 的 Setting.xml 文件\r\n4. pom.xml 文件模板\r\n5. 发布到中心仓库\r\n:::\r\n\r\n## 注册中心仓库账户 \r\n\r\n1. 注册中心仓库的账户：[central.sonatype.com](https://central.sonatype.com)\r\n2. 使用 Github 登录，可以自动获得命名空间 -> 有效的 groupId\r\n3. Generate User Token  ->  自动生成 maven setting.xml 的 server 配置项（修改 id 为 central）\r\n\r\n## GPG\r\n\r\n```powershell\r\n# 安装GPG\r\nwinget install GnuPG.Gpg4win\r\n\r\n# 生成密钥\r\ngpg --full-generate-key\r\n\r\n# 上传公钥到GPG公钥服务器\r\ngpg --keyserver pgp.mit.edu --send-keys <KEY_ID>\r\ngpg --keyserver keyserver.ubuntu.com --send-keys <KEY_ID>\r\n\r\n# 导出公钥\r\ngpg --armor --export <KEY_ID> > public_key_1.asc\r\n# 导出私钥\r\ngpg --armor --export-secret-keys <KEY_ID> > private_key_2.asc\r\n```\r\n\r\n## Maven Setting.xml\r\n\r\n```xml\r\n\t<servers>\r\n\t\t<server>\r\n\t\t\t<id>central</id>\r\n\t\t\t<username>${username}</username>\r\n\t\t\t<password>${token}</password>\r\n\t\t</server>\r\n    </servers>\r\n\r\n\t<profiles>\r\n\t\t<profile>\r\n\t\t\t<id>gpg-profile</id>\r\n\t\t\t<properties>\r\n\t\t\t\t<gpg.keyname> ${KEY_ID} </gpg.keyname>\r\n\t\t\t\t<gpg.passphrase><![CDATA[password]]></gpg.passphrase>\r\n\t\t\t</properties>\r\n\t\t</profile>\r\n\t</profiles>\r\n\t<activeProfiles>\r\n\t\t<activeProfile>gpg-profile</activeProfile>\r\n\t</activeProfiles>\r\n```\r\n\r\n## pom.xml\r\n\r\n```xml\r\n    <groupId>io.github.jxch</groupId>\r\n    <artifactId>capital-py4j-spring-boot-starter</artifactId>\r\n    <version>3.2.5-alpha.1</version>\r\n    <name>capital-py4j-spring-boot-starter</name>\r\n    <description>py4j本地执行引擎与springboot的无缝集成</description>\r\n    <url>https://github.com/jxch-capital/capital-py4j-spring-boot-starter</url>\r\n\r\n    <properties>\r\n        <maven.compiler.source>21</maven.compiler.source>\r\n        <maven.compiler.target>21</maven.compiler.target>\r\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n        <lombok.version>1.18.32</lombok.version>\r\n        <hutool.version>5.8.27</hutool.version>\r\n        <maven-source-plugin.version>3.3.1</maven-source-plugin.version>\r\n        <maven-javadoc-plugin.version>3.6.3</maven-javadoc-plugin.version>\r\n        <maven-gpg-plugin.version>3.2.4</maven-gpg-plugin.version>\r\n        <maven-release-plugin.version>3.0.1</maven-release-plugin.version>\r\n        <central-publishing-maven-plugin.version>0.4.0</central-publishing-maven-plugin.version>\r\n    </properties>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-source-plugin</artifactId>\r\n                <version>${maven-source-plugin.version}</version>\r\n                <executions>\r\n                    <execution>\r\n                        <id>attach-sources</id>\r\n                        <goals>\r\n                            <goal>jar-no-fork</goal>\r\n                        </goals>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-javadoc-plugin</artifactId>\r\n                <version>${maven-javadoc-plugin.version}</version>\r\n                <executions>\r\n                    <execution>\r\n                        <id>attach-javadocs</id>\r\n                        <goals>\r\n                            <goal>jar</goal>\r\n                        </goals>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.sonatype.central</groupId>\r\n                <artifactId>central-publishing-maven-plugin</artifactId>\r\n                <version>${central-publishing-maven-plugin.version}</version>\r\n                <extensions>true</extensions>\r\n                <configuration>\r\n                    <publishingServerId>central</publishingServerId>\r\n                    <tokenAuth>true</tokenAuth>\r\n                    <autoPublish>true</autoPublish>\r\n                    <waitUntil>published</waitUntil>\r\n                </configuration>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-release-plugin</artifactId>\r\n                <version>${maven-release-plugin.version}</version>\r\n                <configuration>\r\n                    <goals>deploy nexus-staging:release</goals>\r\n                    <autoVersionSubmodules>true</autoVersionSubmodules>\r\n                    <useReleaseProfile>false</useReleaseProfile>\r\n                    <releaseProfiles>release</releaseProfiles>\r\n                </configuration>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-gpg-plugin</artifactId>\r\n                <version>${maven-gpg-plugin.version}</version>\r\n                <executions>\r\n                    <execution>\r\n                        <id>sign-artifacts</id>\r\n                        <phase>verify</phase>\r\n                        <goals>\r\n                            <goal>sign</goal>\r\n                        </goals>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n    <licenses>\r\n        <license>\r\n            <name>The Apache Software License, Version 2.0</name>\r\n            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\r\n            <distribution>repo</distribution>\r\n        </license>\r\n    </licenses>\r\n\r\n    <scm>\r\n        <connection>scm:git:git://github.com/jxch-capital/capital-py4j-spring-boot-starter.git</connection>\r\n        <developerConnection>scm:git:ssh://github.com:jxch-capital/capital-py4j-spring-boot-starter.git</developerConnection>\r\n        <url>${developer_github_project_url}</url>\r\n    </scm>\r\n\r\n    <developers>\r\n        <developer>\r\n            <id>${developer_id}</id>\r\n            <name>${developer_name}</name>\r\n            <email>${developer_email}</email>\r\n            <url>${developer_github_url}</url>\r\n        </developer>\r\n    </developers>\r\n\r\n    <distributionManagement>\r\n        <snapshotRepository>\r\n            <id>central</id>\r\n            <url>https://s01.oss.sonatype.org/content/repositories/snapshots</url>\r\n        </snapshotRepository>\r\n        <repository>\r\n            <id>central</id>\r\n            <url>https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/</url>\r\n        </repository>\r\n    </distributionManagement>\r\n```\r\n\r\n## 发布\r\n\r\n```shell\r\nmvn deploy -f pom.xml\r\n```\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "MAVEN 上传到中心仓库",
      "lvl1": "注册中心仓库账户",
      "lvl2": "GPG",
      "lvl3": "Maven Setting.xml",
      "lvl4": "pom.xml",
      "lvl5": "发布"
    },
    "frontmatter": {
      "title": "MAVEN 上传到中心仓库",
      "date": "2025/03/05",
      "tags": [
        "MAVEN"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "PowerShell 目录栈",
    "path": "/blogs/bianmabiji/PowerShellmuluzhan.html",
    "url": "/blogs/bianmabiji/PowerShellmuluzhan.html",
    "content": "---\r\ntitle: PowerShell 目录栈\r\ndate: 2025/04/23\r\ntags:\r\n - PowerShell\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n:::info\r\n如果只是在脚本里临时切换目录，使用 `Push-Location / Pop-Location` 更优雅\r\n:::\r\n\r\n```powershell\r\ntry {\r\n    Push-Location path/to/dir\r\n    # todo ...\r\n}\r\nfinally {\r\n    Pop-Location\r\n}\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "PowerShell 目录栈"
    },
    "frontmatter": {
      "title": "PowerShell 目录栈",
      "date": "2025/04/23",
      "tags": [
        "PowerShell"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "PowerShell 设置定时任务",
    "path": "/blogs/bianmabiji/PowerShellshezhidingshirenwu.html",
    "url": "/blogs/bianmabiji/PowerShellshezhidingshirenwu.html",
    "content": "---\r\ntitle: PowerShell 设置定时任务\r\ndate: 2025/03/05\r\ntags:\r\n - PowerShell\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n::: tip\r\n1. 注册任务\r\n2. 注销任务\r\n\r\n---\r\n\r\n[使用VBS保持PS脚本的静默执行](./VBS静默执行PS脚本.md)\r\n:::\r\n\r\n\r\n## 注册任务\r\n\r\n```powershell\r\n# 使用vbs脚本的好处是可以保持静默执行\r\n$Action = New-ScheduledTaskAction -Execute \"wscript.exe\" -Argument \"D:\\personal-folder\\app\\powershell\\wallpaper-kline.vbs\"\r\n\r\n# 设置开机执行一次\r\n$Trigger1 = New-ScheduledTaskTrigger -AtStartup\r\n# 设置每小时执行一次\r\n$Trigger2 = New-ScheduledTaskTrigger -Once -At (Get-Date).Date -RepetitionInterval (New-TimeSpan -Hours 1)\r\n\r\n# 注册任务\r\n$Settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable -RunOnlyIfNetworkAvailable\r\nRegister-ScheduledTask -Action $Action -Trigger $Trigger1,$Trigger2 -TaskName \"wallpaper-kline-task\" -Description \"wallpaper-kline.vbs\"  -Settings $Settings\r\n```\r\n\r\n## 注销任务\r\n\r\n```powershell\r\nUnregister-ScheduledTask -TaskName \"wallpaper-kline-task\" -Confirm:$false\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "PowerShell 设置定时任务",
      "lvl1": "注册任务",
      "lvl2": "注销任务"
    },
    "frontmatter": {
      "title": "PowerShell 设置定时任务",
      "date": "2025/03/05",
      "tags": [
        "PowerShell"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "Python 导出最简项目依赖",
    "path": "/blogs/bianmabiji/PYdaochuzuijianxiangmuyilai.html",
    "url": "/blogs/bianmabiji/PYdaochuzuijianxiangmuyilai.html",
    "content": "---\r\ntitle: Python 导出最简项目依赖\r\ndate: 2025/03/05\r\ntags:\r\n - Python\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n::: tip\r\n使用 `pipreqs` 导出项目依赖\r\n:::\r\n\r\n## 导出依赖\r\n\r\n```shell\r\n# 安装 pipreqs\r\npip install pipreqs\r\n\r\n# 导出项目依赖到 requirements.txt\r\npipreqs ./ --encoding=utf-8\r\n\r\n# 覆盖 requirements.txt\r\npipreqs ./ --encoding=utf-8 --force\r\n```\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Python 导出最简项目依赖",
      "lvl1": "导出依赖"
    },
    "frontmatter": {
      "title": "Python 导出最简项目依赖",
      "date": "2025/03/05",
      "tags": [
        "Python"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "shlink 部署及 openfeign 调用",
    "path": "/blogs/bianmabiji/shlinkbushujiopenfeigndiaoyong.html",
    "url": "/blogs/bianmabiji/shlinkbushujiopenfeigndiaoyong.html",
    "content": "---\r\ntitle: shlink 部署及 openfeign 调用\r\ndate: 2025/04/16\r\ntags:\r\n - shlink\r\n - openfeign\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n## shlink 部署\r\n\r\n```yml\r\nservices:\r\n  shlink:\r\n    image: shlinkio/shlink:latest\r\n    ports:\r\n      - \"28881:8080\"\r\n    environment:\r\n      - SHLINK_SHORT_CODES_LENGTH=5\r\n      - INITIAL_API_KEY=cda4282f-27a5-4a93-bb8a-47234309628f\r\n      - DB_DRIVER=mysql\r\n      - DB_HOST=mysql_host\r\n      - DB_PORT=3306\r\n      - DB_NAME=shlink\r\n      - DB_USER=shlink\r\n      - DB_PASSWORD=662caa92-1f0e-40f5-9656-2147c76a4f73\r\n```\r\n\r\n## openfeign\r\n\r\n```java\r\n@FeignClient(name = CloudName.SHLINK, path = \"/rest/v3\",\r\n        fallbackFactory = ShlinkClientFallbackFactory.class,\r\n        configuration = ShlinkHeaderConfig.class)\r\npublic interface ShlinkClient {\r\n    @PostMapping(\"/short-urls\")\r\n    ShortUrlRes shortUrls(@RequestBody ShortUrlParam param);\r\n}\r\n```\r\n\r\n```java\r\n@Data\r\n@Builder\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\n@Accessors(chain = true)\r\npublic class ShortUrlParam {\r\n    private String longUrl;\r\n}\r\n```\r\n\r\n```java\r\n@Data\r\n@Builder\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\n@Accessors(chain = true)\r\npublic class ShortUrlRes {\r\n    private String shortUrl;\r\n    private String shortCode;\r\n    private String longUrl;\r\n    @JsonFormat(pattern = \"yyyy-MM-dd'T'HH:mm:ssXXX\")\r\n    private Date dateCreated;\r\n    private String domain;\r\n    private String title;\r\n    private Boolean crawlable;\r\n    private Boolean forwardQuery;\r\n    private Boolean hasRedirectRules;\r\n}\r\n```\r\n\r\n```java\r\n@RequiredArgsConstructor\r\npublic class ShlinkHeaderConfig {\r\n    private final ShlinkConfig shlinkConfig;\r\n    @Bean\r\n    public RequestInterceptor requestInterceptor() {\r\n        return requestTemplate -> requestTemplate.header(\"X-Api-Key\", shlinkConfig.getApiKey());\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n@Data\r\n@Configuration\r\n@ConfigurationProperties(prefix = \"app.shlink\")\r\npublic class ShlinkConfig {\r\n    private String apiKey;\r\n}\r\n```\r\n\r\n```yml\r\napp:\r\n  shlink:\r\n    api-key: cda4282f-27a5-4a93-bb8a-47234309628f\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "shlink 部署及 openfeign 调用",
      "lvl1": "shlink 部署",
      "lvl2": "openfeign"
    },
    "frontmatter": {
      "title": "shlink 部署及 openfeign 调用",
      "date": "2025/04/16",
      "tags": [
        "shlink",
        "openfeign"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "SpringBoot2 Starter 自定义环境变量",
    "path": "/blogs/bianmabiji/SpringBoot2Starterzidingyihuanjingbianliang.html",
    "url": "/blogs/bianmabiji/SpringBoot2Starterzidingyihuanjingbianliang.html",
    "content": "---\r\ntitle: SpringBoot2 Starter 自定义环境变量\r\ndate: 2025/04/12\r\ntags:\r\n - SpringBoot\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n```\r\nMETA-INF\r\n  - application-referenced.yml\r\n  - spring.factories\r\n```\r\n\r\nspring.factories\r\n```prop\r\norg.springframework.boot.env.EnvironmentPostProcessor=package.path.CommonEnvironmentPostProcessor\r\n```\r\n\r\n```java\r\npublic class CommonEnvironmentPostProcessor implements EnvironmentPostProcessor {\r\n    private static final String PROPERTY_SOURCE_NAME = CommonEnvironmentPostProcessor.class.getSimpleName();\r\n\r\n    @Override\r\n    public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {\r\n        YamlPropertySourceLoader loader = new YamlPropertySourceLoader();\r\n        Resource resource = new ClassPathResource(\"META-INF/application-referenced.yml\");\r\n\r\n        if (resource.exists()) {\r\n            try {\r\n                PropertySource<?> yamlProps = loader.load(PROPERTY_SOURCE_NAME, resource).get(0);\r\n                environment.getPropertySources().addLast(yamlProps);  // 注意：使用 `.addLast()`，确保主项目配置优先\r\n            } catch (IOException e) {\r\n                throw new IllegalStateException(\"Failed to load YAML file: \" + resource.getFilename(), e);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "SpringBoot2 Starter 自定义环境变量"
    },
    "frontmatter": {
      "title": "SpringBoot2 Starter 自定义环境变量",
      "date": "2025/04/12",
      "tags": [
        "SpringBoot"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "SpringBoot2 集成 Zipkin 和 Sleuth 实现链路追踪",
    "path": "/blogs/bianmabiji/SpringBoot2jichengZipkinheSleuthshixianlianluzhuizong.html",
    "url": "/blogs/bianmabiji/SpringBoot2jichengZipkinheSleuthshixianlianluzhuizong.html",
    "content": "---\r\ntitle: SpringBoot2 集成 Zipkin 和 Sleuth 实现链路追踪\r\ndate: 2025/04/22\r\ntags:\r\n - SpringBoot\r\n - Zipkin\r\n - Sleuth\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n## 依赖\r\n\r\n```xml\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.7.9</version>\r\n        <relativePath/>\r\n    </parent>\r\n```\r\n\r\n```xml\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-sleuth</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-sleuth-zipkin</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-loadbalancer</artifactId>\r\n        </dependency>\r\n```\r\n\r\n## 配置\r\n\r\n:::tip\r\n- 关闭 sleuth 组件自动注入的链路日志信息：`spring.sleuth.default-logging-pattern-enabled: false`\r\n- logback 自定义链路日志：`%X{traceId:-} %X{spanId:-}`\r\n- logback 中自定义的默认就可以上传到 ELK，而 sleuth 默认输出的则默认上传不到 ELK\r\n- ELK 搭建见：[ELK 部署](../运维手册/ELK部署.md)\r\n:::\r\n\r\n```yml\r\nspring:\r\n  sleuth:\r\n    default-logging-pattern-enabled: false\r\n    jdbc:\r\n      datasource-proxy:\r\n        query:\r\n          enable-logging: true\r\n        slow-query:\r\n          enable-logging: true\r\n      p6spy:\r\n        enable-logging: true\r\n    sampler:\r\n      probability: 1.0\r\n      rate: 100\r\n  zipkin:\r\n    base-url: http://zipkin:port\r\n    sender:\r\n      type: web\r\n```\r\n\r\n## 标签\r\n\r\n:::info\r\n- 多环境公用一个Zipkin的时候，可以使用打标签的方式进行环境隔离\r\n- Zipkin 查询语句：`tagQuery=env=dev`\r\n:::\r\n\r\n```java\r\n@Configuration\r\npublic class ZipkinTracingConfig {\r\n    @Value(\"${spring.profiles.active:unknown}\")  // 读取当前环境\r\n    private String activeProfile;\r\n\r\n    @Bean\r\n    public SpanHandler spanHandler() {\r\n        return new SpanHandler() {\r\n            @Override\r\n            public boolean end(TraceContext context, MutableSpan span, Cause cause) {\r\n                span.tag(\"env\", activeProfile); // 给 Zipkin 添加环境信息\r\n                return true;\r\n            }\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "SpringBoot2 集成 Zipkin 和 Sleuth 实现链路追踪",
      "lvl1": "依赖",
      "lvl2": "配置",
      "lvl3": "标签"
    },
    "frontmatter": {
      "title": "SpringBoot2 集成 Zipkin 和 Sleuth 实现链路追踪",
      "date": "2025/04/22",
      "tags": [
        "SpringBoot",
        "Zipkin",
        "Sleuth"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "SpringBoot3 集成 GraalVM 云原生",
    "path": "/blogs/bianmabiji/SpringBoot3jichengGraalVMyunyuansheng.html",
    "url": "/blogs/bianmabiji/SpringBoot3jichengGraalVMyunyuansheng.html",
    "content": "---\r\ntitle: SpringBoot3 集成 GraalVM 云原生\r\ndate: 2025/04/18\r\ntags:\r\n - GraalVM\r\n - SpringBoot\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n## 依赖\r\n\r\n:::info\r\nSpringBoot 版本必须在 3.4.4 之上\r\n:::\r\n\r\n```xml\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>3.4.4</version>\r\n    </parent>\r\n```\r\n\r\n```xml\r\n    <build>\r\n        <finalName>image-name</finalName>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.graalvm.buildtools</groupId>\r\n                <artifactId>native-maven-plugin</artifactId>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n                <version>3.4.4</version>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n```\r\n\r\n## 构建发布\r\n\r\n```shell\r\nmvn clean -Pnative spring-boot:build-image -f pom.xml\r\ndocker tag image-name:{version} jxch/image-name:latest\r\ndocker push jxch/image-name:latest\r\n```\r\n\r\n## 兼容性\r\n\r\n### 反射声明配置\r\n\r\n需要声明哪些类被反射过（尤其是被JSON序列化的类）\r\n\r\n```java\r\n@Configuration\r\n@RegisterReflectionForBinding({\r\n        CPunchCardNormal.class, CPunchCardState.class, UserConfig.class, User.class\r\n})\r\npublic class NativeReflectionConfig {\r\n}\r\n```\r\n\r\n### 静态资源声明配置\r\n\r\n声明用到了哪些 resources 目录下的静态资源文件\r\n\r\n```java\r\n@Configuration\r\n@ImportRuntimeHints(NativeRuntimeHints.class)\r\npublic class NativeRuntimeHints implements RuntimeHintsRegistrar {\r\n    @Override\r\n    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {\r\n        hints.resources().registerPattern(\"xxx.json\");\r\n    }\r\n}\r\n```\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "SpringBoot3 集成 GraalVM 云原生",
      "lvl1": "依赖",
      "lvl2": "构建发布",
      "lvl3": "兼容性"
    },
    "frontmatter": {
      "title": "SpringBoot3 集成 GraalVM 云原生",
      "date": "2025/04/18",
      "tags": [
        "GraalVM",
        "SpringBoot"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "SpringBoot 集成 Dockerfile 健康检查",
    "path": "/blogs/bianmabiji/SpringBootjichengDockerfilejiankangjiancha.html",
    "url": "/blogs/bianmabiji/SpringBootjichengDockerfilejiankangjiancha.html",
    "content": "---\r\ntitle: SpringBoot 集成 Dockerfile 健康检查\r\ndate: 2025/04/23\r\ntags:\r\n - Docker\r\n - SpringBoot\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n:::info\r\n健康检查成功后，容器才视为启动成功，包括 docker swarm 的 update 也是这样，可以利用这个特性实现集群的不停机更新\r\n:::\r\n\r\n## HEALTHCHECK\r\n\r\n```dockerfile\r\nENV ACTUATOR_PORT=13011\r\nENV ACTUATOR_USER=admin\r\nENV ACTUATOR_PASS=123456\r\n\r\nHEALTHCHECK --interval=30s --timeout=10s --start-period=300s CMD curl -f -u $ACTUATOR_USER:$ACTUATOR_PASS http://127.0.0.1:$ACTUATOR_PORT/actuator/health || exit 1\r\n\r\nENTRYPOINT [...]\r\n```\r\n\r\n## 依赖\r\n\r\n```xml\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-actuator</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-security</artifactId>\r\n        </dependency>\r\n```\r\n\r\n## 配置\r\n\r\n```yml\r\nmanagement:\r\n  server:\r\n    port: 13011\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: '*'\r\n\r\nspring:\r\n  security:\r\n    user:\r\n      name: admin\r\n      password: 123456\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "SpringBoot 集成 Dockerfile 健康检查",
      "lvl1": "HEALTHCHECK",
      "lvl2": "依赖",
      "lvl3": "配置"
    },
    "frontmatter": {
      "title": "SpringBoot 集成 Dockerfile 健康检查",
      "date": "2025/04/23",
      "tags": [
        "Docker",
        "SpringBoot"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "Vaadin 集成 SpringBoot3 及 GraalVM 云原生",
    "path": "/blogs/bianmabiji/VaadinjichengSpringBoot3jiGraalVMyunyuansheng.html",
    "url": "/blogs/bianmabiji/VaadinjichengSpringBoot3jiGraalVMyunyuansheng.html",
    "content": "---\r\ntitle: Vaadin 集成 SpringBoot3 及 GraalVM 云原生\r\ndate: 2025/04/18\r\ntags:\r\n - GraalVM\r\n - SpringBoot\r\n - Vaadin\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n## 依赖\r\n\r\n:::info\r\n- SpringBoot 版本必须在 3.4.4 之上\r\n- Vaadin 版本必须在 24.7.2 之上\r\n:::\r\n\r\n```xml\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>3.4.4</version>\r\n    </parent>\r\n```\r\n\r\n```xml\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>com.vaadin</groupId>\r\n            <artifactId>vaadin-spring-boot-starter</artifactId>\r\n            <version>24.7.2</version>\r\n        </dependency>\r\n```\r\n\r\n```xml\r\n    <build>\r\n        <finalName>image-name</finalName>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.graalvm.buildtools</groupId>\r\n                <artifactId>native-maven-plugin</artifactId>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n                <version>3.4.4</version>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>com.vaadin</groupId>\r\n                <artifactId>vaadin-maven-plugin</artifactId>\r\n                <version>24.7.2</version>\r\n                <executions>\r\n                    <execution>\r\n                        <goals>\r\n                            <goal>prepare-frontend</goal>\r\n                            <goal>build-frontend</goal>\r\n                        </goals>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n```\r\n\r\n## 兼容性\r\n\r\n:::info\r\nVaadin 组件中用到过的所有类都必须声明反射\r\n\r\n其他兼容性（静态资源、反射等）参见 [SpringBoot3集成GraalVM云原生](./SpringBoot3集成GraalVM云原生.md)\r\n:::\r\n\r\n## view\r\n\r\n```java\r\n@Route(\"clock\")\r\npublic class ClockView extends VerticalLayout {\r\n    public ClockView(){\r\n        // todo 在构造方法中编写这个页面（可以通过构造方法参数直接注入 SpringBean）\r\n    }\r\n}\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Vaadin 集成 SpringBoot3 及 GraalVM 云原生",
      "lvl1": "依赖",
      "lvl2": "兼容性",
      "lvl3": "view"
    },
    "frontmatter": {
      "title": "Vaadin 集成 SpringBoot3 及 GraalVM 云原生",
      "date": "2025/04/18",
      "tags": [
        "GraalVM",
        "SpringBoot",
        "Vaadin"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "VBS 静默执行 PowerShell 脚本",
    "path": "/blogs/bianmabiji/VBSjingmozhixingPSjiaoben.html",
    "url": "/blogs/bianmabiji/VBSjingmozhixingPSjiaoben.html",
    "content": "---\r\ntitle: VBS 静默执行 PowerShell 脚本\r\ndate: 2025/03/05\r\ntags:\r\n - VBS\r\ncategories:\r\n - 编码笔记\r\n---\r\n\r\n## 创建 VBS 脚本\r\n\r\n```powershell\r\nSet WshShell = CreateObject(\"WScript.Shell\")\r\nWshShell.Run \"powershell.exe -WindowStyle Hidden -File D:\\personal-folder\\app\\powershell\\wallpaper-kline.ps1\", 0\r\nSet WshShell = Nothing\r\n```\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "VBS 静默执行 PowerShell 脚本",
      "lvl1": "创建 VBS 脚本"
    },
    "frontmatter": {
      "title": "VBS 静默执行 PowerShell 脚本",
      "date": "2025/03/05",
      "tags": [
        "VBS"
      ],
      "categories": [
        "编码笔记"
      ]
    },
    "type": "content"
  },
  {
    "title": "dnsmasq 部署",
    "path": "/blogs/yunweishouce/dnsmasqbushu.html",
    "url": "/blogs/yunweishouce/dnsmasqbushu.html",
    "content": "---\r\ntitle: dnsmasq 部署\r\ndate: 2025/03/05\r\ntags:\r\n - dnsmasq\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n::: tip\r\n1. 使用 docker 部署，docker-compose.yml 文件\r\n2. 配置文件，dnsmasq.conf 文件\r\n:::\r\n\r\n## docker-compose.yml\r\n\r\n```yml\r\nservices:\r\n  dns-server:\r\n    image: jpillora/dnsmasq\r\n    container_name: dns-server\r\n    restart: unless-stopped\r\n    environment:\r\n      - TZ=Asia/Shanghai\r\n      - HTTP_USER=username\r\n      - HTTP_PASS=password\r\n    ports:\r\n      - \"53:53/udp\"\r\n      - \"5380:8080\"\r\n    volumes:\r\n      - \"./dns/dnsmasq.conf:/etc/dnsmasq.conf\"\r\n```\r\n\r\n## dnsmasq.conf\r\n\r\n```shell\r\n# 服务器上游DNS服务器地址\r\nresolv-file=/etc/resolv.conf\r\n# 默认缓存条数150，这里增加到1000\r\ncache-size=1000\r\n# 重启后清空缓存\r\nclear-on-reload\r\n\r\n# DNS 服务器\r\nserver=8.8.4.4\r\nserver=8.8.8.8\r\nserver=4.2.2.1\r\nserver=4.2.2.2\r\nserver=114.114.114.114\r\n\r\n# 自定义域名\r\naddress=/example.com/192.168.1.10\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "dnsmasq 部署",
      "lvl1": "docker-compose.yml",
      "lvl2": "dnsmasq.conf"
    },
    "frontmatter": {
      "title": "dnsmasq 部署",
      "date": "2025/03/05",
      "tags": [
        "dnsmasq"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "Docker Swarm 将服务部署到指定标签的节点上",
    "path": "/blogs/yunweishouce/DockerSwarmjiangfuwubushudaozhidingbiaoqiandejiedianshang.html",
    "url": "/blogs/yunweishouce/DockerSwarmjiangfuwubushudaozhidingbiaoqiandejiedianshang.html",
    "content": "---\r\ntitle: Docker Swarm 将服务部署到指定标签的节点上\r\ndate: 2025/03/05\r\ntags:\r\n - Docker\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n::: tip \r\n1. 给节点打标签\r\n2. 给服务加约束\r\n:::\r\n\r\n```shell\r\n# 给节点打标签\r\ndocker node update --label-add memory=high NODE_ID\r\n\r\n# 给服务添加约束，他就会自动调度到特定标签的节点上\r\ndocker service update --constraint-add 'node.labels.memory == high' SERVICE_ID\r\n```\r\n\r\n```shell\r\n# 查看节点上的标签\r\ndocker node inspect <node_id> --format '{{json .Spec.Labels}}'\r\n```\r\n\r\n```shell\r\n# 使该节点不接受任务调度，但是仍然可以通过该节点的端口访问集群中的服务\r\ndocker node update --availability drain <node_id>\r\n```\r\n\r\n```yml\r\nservices:\r\n  app:\r\n    image: app-images\r\n    deploy:\r\n      placement:\r\n        constraints:\r\n          - node.labels.memory == high\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Docker Swarm 将服务部署到指定标签的节点上"
    },
    "frontmatter": {
      "title": "Docker Swarm 将服务部署到指定标签的节点上",
      "date": "2025/03/05",
      "tags": [
        "Docker"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "Docker 容器启动时提示内存太小",
    "path": "/blogs/yunweishouce/Dockerrongqiqidongshitishinacuntaixiao.html",
    "url": "/blogs/yunweishouce/Dockerrongqiqidongshitishinacuntaixiao.html",
    "content": "---\r\ntitle: Docker 容器启动时提示内存太小\r\ndate: 2025/03/05\r\ntags:\r\n - Docker\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n::: danger 类似的报错信息\r\n`Maximum number of memory map areas per process (vm.max_map_count) 262144 is too low, recommended value: 1048575, you can change it with sysctl.`\r\n:::\r\n\r\n## 解决方案\r\n\r\n:::: code-group\r\n::: code-group-item LINUX\r\n```bash\r\nsysctl -w vm.max_map_count=1048575\r\n```\r\n:::\r\n::: code-group-item WINDOWS\r\n```powershell\r\nwsl -d docker-desktop sh -c \"sysctl -w vm.max_map_count=1048575\"\r\n```\r\n:::\r\n::::\r\n\r\n::: info \r\n1. 提示应该设置多少就设置多少\r\n2. 然后重启docker服务即可\r\n:::\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Docker 容器启动时提示内存太小",
      "lvl1": "解决方案"
    },
    "frontmatter": {
      "title": "Docker 容器启动时提示内存太小",
      "date": "2025/03/05",
      "tags": [
        "Docker"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "Docker 清理",
    "path": "/blogs/yunweishouce/Dockerqingli.html",
    "url": "/blogs/yunweishouce/Dockerqingli.html",
    "content": "---\r\ntitle: Docker 清理\r\ndate: 2025/03/05\r\ntags:\r\n - Docker\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n::: tip\r\n通常可以直接使用 `docker system prune --all -f` 命令进行深度清理并且无需手动确认\r\n:::\r\n\r\n|命令|作用|\r\n|-|-|\r\n|`docker container prune`|容器清理|\r\n|`docker image prune`|镜像清理|\r\n|`docker volume prune`|数据卷清理|\r\n|`docker builder prune`|缓存清理|\r\n|`docker system prune`|一键清理|\r\n|`docker system prune -a`|深度清理|\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Docker 清理"
    },
    "frontmatter": {
      "title": "Docker 清理",
      "date": "2025/03/05",
      "tags": [
        "Docker"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "ELK 部署",
    "path": "/blogs/yunweishouce/ELKbushu.html",
    "url": "/blogs/yunweishouce/ELKbushu.html",
    "content": "---\r\ntitle: ELK 部署\r\ndate: 2025/04/16\r\ntags:\r\n - elasticsearch\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n## docker-compose.yml\r\n\r\n```yml\r\nservices:\r\n  elasticsearch: \r\n    image: elasticsearch:8.16.1\r\n    restart: always\r\n    environment:\r\n      - discovery.type=single-node \r\n      - xpack.security.enabled=true\r\n    volumes:\r\n      - /mnt/nexus3/es_data:/usr/share/elasticsearch/data \r\n    logging:\r\n      driver: \"json-file\"\r\n      options:\r\n        max-size: \"50m\"\r\n        max-file: \"3\"\r\n  kibana: \r\n    image: kibana:8.16.1 \r\n    ports:\r\n      - \"12563:5601\"\r\n    environment:\r\n      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200\r\n      - XPACK_SECURITY_ENABLED=true\r\n      - ELASTICSEARCH_USERNAME=kibana_system\r\n      - ELASTICSEARCH_PASSWORD=\"3UGDvTkAmzhprC5*9PUw\"\r\n    depends_on:\r\n      - elasticsearch\r\n    logging:\r\n      driver: \"json-file\"\r\n      options:\r\n        max-size: \"50m\"\r\n        max-file: \"3\"\r\n  zipkin:\r\n    image: bitnami/zipkin:3\r\n    ports:\r\n      - \"12411:9411\"\r\n    environment:\r\n      - STORAGE_TYPE=elasticsearch\r\n      - ES_HOSTS=elasticsearch:9200\r\n      - ES_USERNAME=elastic\r\n      - ES_PASSWORD=rC4hG9mR9DUC109=DeS8\r\n    depends_on:\r\n      - elasticsearch\r\n    logging:\r\n      driver: \"json-file\"\r\n      options:\r\n        max-size: \"50m\"\r\n        max-file: \"3\"\r\n  logstash:\r\n    image: bitnami/logstash:8.17.0\r\n    ports: \r\n      - \"5044:8080\"\r\n    volumes:\r\n      - ./logstash.conf:/opt/bitnami/logstash/pipeline/logstash.conf\r\n    logging:\r\n      driver: \"json-file\"\r\n      options:\r\n        max-size: \"50m\"\r\n        max-file: \"3\"\r\n```\r\n\r\n## logstash.conf\r\n\r\n```config\r\ninput {\r\n  tcp {\r\n    port => 8080 \r\n    codec => json_lines \r\n  }\r\n}\r\n\r\n\r\noutput {\r\n  elasticsearch {\r\n    hosts => [\"http://elasticsearch:9200\"] \r\n    user => \"elastic\"\r\n    password => \"rC4hG9mR9DUC109=DeS8\"\r\n    index => \"logs-%{+YYYY.MM.dd}\"\r\n    ssl => false \r\n  }\r\n}\r\n```\r\n\r\n## 设置密码\r\n\r\n```bash\r\n# 进入 elasticsearch 容器内部\r\ndocker exec -it <elasticsearch> sh\r\n\r\n# 设置超级用户的密码，此用户名密码可以用在logstash、zipkin和kibana web ui的登录上\r\nbin/elasticsearch-reset-password -u elastic\r\n\r\n# 设置kibana用户的密码，此用户专用于kibana容器与elasticsearch容器的交互\r\nbin/elasticsearch-reset-password -u kibana_system\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "ELK 部署",
      "lvl1": "docker-compose.yml",
      "lvl2": "logstash.conf",
      "lvl3": "设置密码"
    },
    "frontmatter": {
      "title": "ELK 部署",
      "date": "2025/04/16",
      "tags": [
        "elasticsearch"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "Linux 关闭 iptables 防火墙",
    "path": "/blogs/yunweishouce/Linuxguanbiiptablesfanghuoqiang.html",
    "url": "/blogs/yunweishouce/Linuxguanbiiptablesfanghuoqiang.html",
    "content": "---\r\ntitle: Linux 关闭 iptables 防火墙\r\ndate: 2025/03/11\r\ntags:\r\n - Linux\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n## 允许所有流量\r\n\r\n```shell\r\niptables -P FORWARD ACCEPT \r\niptables -P OUTPUT ACCEPT \r\niptables -P INPUT ACCEPT\r\niptables -F \r\n```\r\n\r\n::: warning\r\n该方式会在重启后失效\r\n:::\r\n\r\n## 自动生效\r\n\r\n```shell\r\napt install iptables-persistent\r\n\r\nnetfilter-persistent save\r\n\r\n# 重启后验证\r\niptables -L -v\r\n```\r\n\r\n::: tip\r\n适用于 Debian/Ubuntu 系统\r\n:::\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Linux 关闭 iptables 防火墙",
      "lvl1": "允许所有流量",
      "lvl2": "自动生效"
    },
    "frontmatter": {
      "title": "Linux 关闭 iptables 防火墙",
      "date": "2025/03/11",
      "tags": [
        "Linux"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "Linux 开启 BBR",
    "path": "/blogs/yunweishouce/LinuxkaiqiBBR.html",
    "url": "/blogs/yunweishouce/LinuxkaiqiBBR.html",
    "content": "---\r\ntitle: Linux 开启 BBR\r\ndate: 2025/03/05\r\ntags:\r\n - Linux\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n## 开启 BBR\r\n\r\n```bash\r\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\r\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\r\n\r\n# 生效\r\nsysctl -p\r\n\r\n# 查看内核是否已开启BBR\r\nsysctl net.ipv4.tcp_available_congestion_control\r\n\r\n# 查看BBR是否启动\r\nlsmod | grep bbr\r\n```\r\n\r\n::: warning 内核版本\r\n1. Linux 内核版本 4.9 以上才可以开启\r\n2. 查看版本是否符合要求：`uname -r` \r\n:::\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Linux 开启 BBR",
      "lvl1": "开启 BBR"
    },
    "frontmatter": {
      "title": "Linux 开启 BBR",
      "date": "2025/03/05",
      "tags": [
        "Linux"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "Linux 添加 Swap 交换空间",
    "path": "/blogs/yunweishouce/LinuxtianjiaSwapjiaohuankongjian.html",
    "url": "/blogs/yunweishouce/LinuxtianjiaSwapjiaohuankongjian.html",
    "content": "---\r\ntitle: Linux 添加 Swap 交换空间\r\ndate: 2025/03/07\r\ntags:\r\n - Linux\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n## 添加交换空间\r\n\r\n```bash\r\nmkdir /swap\r\n\r\n# 创建交换空间文件\r\nfallocate -l 2G /swap/swapfile1\r\n# 或者使用 dd 命令\r\ndd if=/dev/zero of=/swap/swapfile1 bs=1024 count=2097152\r\n\r\n# 启用并挂载交换空间\r\nchmod 600 /swap/swapfile1\r\nmkswap /swap/swapfile1\r\nswapon /swap/swapfile1\r\necho \"/swap/swapfile1 swap swap defaults 0 0\" | sudo tee -a /etc/fstab\r\n\r\n# 查看是否挂载成功\r\nswapon --show\r\nfree -h\r\n```\r\n\r\n## 删除交换空间\r\n```bash\r\n# 卸载交换空间\r\nswapoff -v /swap/swapfile1\r\n\r\n# 删除挂载交换空间的配置\r\nvi /etc/fstab\r\nrm /swap/swapfile1\r\n```\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Linux 添加 Swap 交换空间",
      "lvl1": "添加交换空间",
      "lvl2": "删除交换空间"
    },
    "frontmatter": {
      "title": "Linux 添加 Swap 交换空间",
      "date": "2025/03/07",
      "tags": [
        "Linux"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "MYSQL 数据导出导入",
    "path": "/blogs/yunweishouce/MYSQLshujudaochudaoru.html",
    "url": "/blogs/yunweishouce/MYSQLshujudaochudaoru.html",
    "content": "---\r\ntitle: MYSQL 数据导出导入\r\ndate: 2025/03/05\r\ntags:\r\n - MYSQL\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n::: tip\r\n1. 安装 mysqlsh\r\n2. 导出数据\r\n3. 导入数据（需要开启性能模式）\r\n:::\r\n\r\n## 安装 mysqlsh\r\n\r\n```shell\r\nwinget install Oracle.MySQLShell\r\nmysqlsh\r\n```\r\n\r\n## 导出\r\n\r\n```js\r\n\\connect username@host\r\n\\js\r\nutil.dumpTables(\"asktrue_exam\", [\"project_exam_student_result\"], \"E:\\\\DB\\\\asktrue\")\r\nutil.dumpSchemas([\"staffcloud_crm\", \"staffcloud_oa\"], \"E:\\\\DB\\\\staffcloud\");\r\n\r\n// 移除 definer，比如创建该库的用户名\r\nutil.dumpSchemas([\"staffcloud_crm\", \"staffcloud_oa\"], \"E:\\\\DB\\\\staffcloud\", {compatibility:[\"strip_definers\"]});\r\n```\r\n\r\n## 导入\r\n\r\n```js\r\n\\connect username@host\r\n\\js\r\nutil.loadDump(\"E:\\\\DB\\\\asktrue\\\\project_exam_student_result\", {threads: 4});\r\n```\r\n\r\n::: info 需要开启性能模式\r\n开启性能模式：`performance_schema=ON`\r\n:::\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "MYSQL 数据导出导入",
      "lvl1": "安装 mysqlsh",
      "lvl2": "导出",
      "lvl3": "导入"
    },
    "frontmatter": {
      "title": "MYSQL 数据导出导入",
      "date": "2025/03/05",
      "tags": [
        "MYSQL"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "V2fly Shadowsocks 等翻墙服务部署",
    "path": "/blogs/yunweishouce/v2fly_shadowsocksdengfanqiangfuwubushu.html",
    "url": "/blogs/yunweishouce/v2fly_shadowsocksdengfanqiangfuwubushu.html",
    "content": "---\r\ntitle: V2fly Shadowsocks 等翻墙服务部署\r\ndate: 2025/03/08\r\ntags:\r\n - 翻墙\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n::: info\r\n替换一下各配置文件中的 uuid 就可以了\r\n:::\r\n\r\n## docker swarm 部署\r\n\r\n```yml\r\nservices:\r\n  shadowsocks: \r\n    image: shadowsocks/shadowsocks-libev \r\n    restart: unless-stopped\r\n    ports: \r\n      - 12346:12346\r\n      - 12346:12346/udp \r\n    configs: \r\n      - source: shadowsocks_config\r\n        target: /etc/shadowsocks-libev/config.json \r\n    environment:\r\n      - DNS_ADDRS=8.8.8.8,8.8.4.4\r\n    command: ss-server -c /etc/shadowsocks-libev/config.json \r\n  v2fly:\r\n    image: v2fly/v2fly-core\r\n    restart: unless-stopped\r\n    ports:\r\n      - 12345:12345\r\n    configs: \r\n      - source: v2fly_config\r\n        target: /etc/v2ray/config.json\r\n    entrypoint: [\"v2ray\", \"run\",  \"-c\", \"/etc/v2ray/config.json\"]\r\n\r\n\r\nconfigs:\r\n  shadowsocks_config:\r\n    file: /root/server/config/shadowsocks/config.json \r\n  v2fly_config:\r\n    file: /root/server/config/v2fly/config.json\r\n```\r\n\r\n## shadowsocks config.json\r\n\r\n```json\r\n{\r\n    \"server\":\"0.0.0.0\",\r\n    \"server_port\":12346,\r\n    \"password\":\"uuid\",\r\n    \"timeout\":3000,\r\n    \"method\":\"aes-256-gcm\",\r\n    \"fast_open\":false,\r\n    \"mode\":\"tcp_and_udp\"\r\n}\r\n\r\n```\r\n\r\n## v2fly config.json\r\n\r\n```json\r\n{\r\n    \"log\": {\r\n        \"access\": \"/var/log/v2ray/access.log\",\r\n        \"error\": \"/var/log/v2ray/error.log\",\r\n        \"loglevel\": \"warning\"\r\n    },\r\n    \"inbound\": {\r\n        \"port\": 12345,\r\n        \"protocol\": \"vmess\",\r\n        \"settings\": {\r\n            \"clients\": [\r\n                {\r\n                    \"id\": \"uuid\",\r\n                    \"level\": 1,\r\n                    \"alterId\": 0\r\n                }\r\n            ]\r\n        }\r\n    },\r\n    \"outbound\": {\r\n        \"protocol\": \"freedom\",\r\n        \"settings\": {}\r\n    },\r\n    \"inboundDetour\": [],\r\n    \"outboundDetour\": [\r\n        {\r\n            \"protocol\": \"blackhole\",\r\n            \"settings\": {},\r\n            \"tag\": \"blocked\"\r\n        }\r\n    ],\r\n    \"routing\": {\r\n        \"strategy\": \"rules\",\r\n        \"settings\": {\r\n            \"rules\": [\r\n                {\r\n                    \"type\": \"field\",\r\n                    \"ip\": [\r\n                        \"0.0.0.0/8\",\r\n                        \"10.0.0.0/8\",\r\n                        \"100.64.0.0/10\",\r\n                        \"127.0.0.0/8\",\r\n                        \"169.254.0.0/16\",\r\n                        \"172.16.0.0/12\",\r\n                        \"192.0.0.0/24\",\r\n                        \"192.0.2.0/24\",\r\n                        \"192.168.0.0/16\",\r\n                        \"198.18.0.0/15\",\r\n                        \"198.51.100.0/24\",\r\n                        \"203.0.113.0/24\",\r\n                        \"::1/128\",\r\n                        \"fc00::/7\",\r\n                        \"fe80::/10\"\r\n                    ],\r\n                    \"outboundTag\": \"blocked\"\r\n                }\r\n            ]\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "V2fly Shadowsocks 等翻墙服务部署",
      "lvl1": "docker swarm 部署",
      "lvl2": "shadowsocks config.json",
      "lvl3": "v2fly config.json"
    },
    "frontmatter": {
      "title": "V2fly Shadowsocks 等翻墙服务部署",
      "date": "2025/03/08",
      "tags": [
        "翻墙"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "Windows 使用 Diskpart 永久固定 USB 盘符",
    "path": "/blogs/yunweishouce/WINshiyongDiskpartyongjiugudingUSBpanfu.html",
    "url": "/blogs/yunweishouce/WINshiyongDiskpartyongjiugudingUSBpanfu.html",
    "content": "---\r\ntitle: Windows 使用 Diskpart 永久固定 USB 盘符\r\ndate: 2025/03/05\r\ntags:\r\n - Windows\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n::: tip Diskpart\r\n先执行 Diskpart 命令，进入 Diskpart 命令窗\r\n:::\r\n\r\n```powershell\r\n# 列出所有的硬盘\r\nlist volume\r\n\r\n# 选择需要操作的硬盘\r\nselect volume 6\r\n\r\n# 手动设置盘符\r\nassign letter=U\r\n```\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Windows 使用 Diskpart 永久固定 USB 盘符"
    },
    "frontmatter": {
      "title": "Windows 使用 Diskpart 永久固定 USB 盘符",
      "date": "2025/03/05",
      "tags": [
        "Windows"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "Windows 设置 Route 在连接 VPN 的同时保持对互联网的正常访问",
    "path": "/blogs/yunweishouce/WINshezhiRoutezailianjieVPNdetongshibaochiduihulianwangdezhengchangfangwen.html",
    "url": "/blogs/yunweishouce/WINshezhiRoutezailianjieVPNdetongshibaochiduihulianwangdezhengchangfangwen.html",
    "content": "---\r\ntitle: Windows 设置 Route 在连接 VPN 的同时保持对互联网的正常访问\r\ndate: 2025/03/08\r\ntags:\r\n - Windows\r\ncategories:\r\n - 运维手册\r\n---\r\n\r\n## 操作方法\r\n\r\n1. `win+R` 输入 `ncpa.cpl`，按回车\r\n2. 右键需要操作的 VPN 设备，点击`属性`\r\n3. 点击`网络`选项卡，双击 `TCP/IPv4`，点击`高级`\r\n4. 取消勾选：`在远程网络上使用默认网关`\r\n5. 连接VPN\r\n6. 管理员模式打开 `powershell` 或 `cmd`\r\n7. 输入命令 `ipconfig /all` 回车，查看需要操作的VPN（如PPP连接）的IP地址，如`192.168.33.19`\r\n8. 添加永久静态路由：`route add 172.16.0.0 mask 255.255.0.0  192.168.33.19 -p` \r\n   - 将 `172.16.0.0` 网段，子网掩码为 `255.255.0.0` 的所有流量通过 `192.168.33.19` 接口访问，而 `192.168.33.19` 正是该VPN的接口\r\n\r\n::: info\r\n该方法的原理是，仅让特定网段的流量走VPN，其他流量依然走本地默认路由\r\n:::\r\n\r\n## Powershell 脚本\r\n\r\n```powershell\r\n# auto-vpn-route.ps1\r\n\r\nparam([String]$vpn, [String]$ip, [String]$mask)\r\n\r\n$vpn_ipv4 = (Get-NetIPAddress | Where-Object {$_.InterfaceAlias -eq $vpn}).IPAddress\r\n\r\nWrite-Host \"vpn: $vpn; vpn-ipv4: $vpn_ipv4\"\r\nIf([String]::IsNullOrEmpty($vpn_ipv4)) {\r\n    Write-Warning \"请连接 VPN：$vpn\"\r\n} Else {\r\n    Write-Host \"route delete $ip\" -ForegroundColor DarkGray\r\n    route delete $ip\r\n    Write-Host \"route add $ip mask $mask $vpn_ipv4\" -ForegroundColor DarkGray\r\n    route add $ip mask $mask $vpn_ipv4\r\n\r\n    If([String]::IsNullOrEmpty((route print | Select-String -Pattern \"\\s0.0.0.0\" | Select-String $vpn_ipv4))) {\r\n        Write-Host \"操作完成！可使用 route print | select-string $ip 查询路由表是否修改。\"\r\n    } Else {\r\n        Write-Host \"route delete $ip\" -ForegroundColor DarkGray\r\n        route delete $ip\r\n        Write-Warning \"请去控制面板关闭 $vpn 网卡的默认网关功能\" \r\n        Write-Warning \"参见：ncpa.cpl -> $vpn -> 属性 -> 网络 -> (TCP/IPv4) -> 高级 -> 在远程网络上使用默认网关\" \r\n        Write-Warning \"重新连接 $vpn\"\r\n    }\r\n}\r\n```\r\n\r\n```powershell\r\n.\\auto-vpn-route.ps1 -vpn 云开发 -ip 172.0.0.0 -mask 255.0.0.0\r\n```\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Windows 设置 Route 在连接 VPN 的同时保持对互联网的正常访问",
      "lvl1": "操作方法",
      "lvl2": "Powershell 脚本"
    },
    "frontmatter": {
      "title": "Windows 设置 Route 在连接 VPN 的同时保持对互联网的正常访问",
      "date": "2025/03/08",
      "tags": [
        "Windows"
      ],
      "categories": [
        "运维手册"
      ]
    },
    "type": "content"
  },
  {
    "title": "JAVA 架构师学习笔记",
    "path": "/docs/architect/architect.html",
    "url": "/docs/architect/architect.html",
    "content": "---\r\ntitle: JAVA 架构师学习笔记\r\ndate: 2025/03/04\r\n---\r\n\r\n## 学习路径\r\n\r\n- 并发编程\r\n- 设计模式\r\n- JAVA反射、流式编程、编码规范\r\n- Spring、SpringBoot（核心启动流程、常见扩展点）\r\n- SpringCloud（微服务、分布式）\r\n- MySQL、MybatisPlus\r\n- 中间件（Redis、Sharding-Sphere、Zookeeper、RabbitMQ、Kafka、RocketMQ、Dubbo）\r\n- 网络编程（Netty）\r\n- JVM（内存模型、垃圾回收、GraalVM）\r\n- 性能调优（数据库、JVM、Tomcat）\r\n- MonoDB、ElasticSearch\r\n- clickhouse、Neo4j\r\n- Docker+K8S\r\n- 架构设计（DDD）\r\n- webflux\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "JAVA 架构师学习笔记",
      "lvl1": "学习路径"
    },
    "frontmatter": {
      "title": "JAVA 架构师学习笔记",
      "date": "2025/03/04"
    },
    "type": "content"
  },
  {
    "title": "读书笔记",
    "path": "/docs/book/book.html",
    "url": "/docs/book/book.html",
    "content": "---\r\ntitle: 读书笔记\r\ndate: 2025/03/08\r\n---\r\n\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "读书笔记"
    },
    "frontmatter": {
      "title": "读书笔记",
      "date": "2025/03/08"
    },
    "type": "content"
  },
  {
    "title": "日记",
    "path": "/docs/diary/diary.html",
    "url": "/docs/diary/diary.html",
    "content": "---\r\ntitle: 日记\r\npassword: b593bf97f44387eb6fdc629acef2d138\r\ndate: 2025/03/08\r\n---\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "日记"
    },
    "frontmatter": {
      "title": "日记",
      "password": "b593bf97f44387eb6fdc629acef2d138",
      "date": "2025/03/08"
    },
    "type": "content"
  },
  {
    "title": "计算机技术栈",
    "path": "/docs/it/it.html",
    "url": "/docs/it/it.html",
    "content": "---\r\ntitle: 计算机技术栈\r\ndate: 2025/03/08\r\n---\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "计算机技术栈"
    },
    "frontmatter": {
      "title": "计算机技术栈",
      "date": "2025/03/08"
    },
    "type": "content"
  },
  {
    "title": "感谢打赏",
    "path": "/docs/others/donate.html",
    "url": "/docs/others/donate.html",
    "content": "---\r\ntitle: 感谢打赏\r\ndate: 2025/03/05\r\n---\r\n\r\n<div style=\"display: flex; justify-content: space-around; flex-wrap: wrap;\">\r\n    <img src=\"@source/docs/others/static/收款码-支付宝.jpg\" alt=\"描述\" width=\"300\" height=\"200\">\r\n    <img src=\"@source/docs/others/static/收款码-微信.jpg\" alt=\"描述\" width=\"300\" height=\"200\">\r\n    <img src=\"@source/docs/others/static/收款码-QQ.jpg\" alt=\"描述\" width=\"300\" height=\"200\">\r\n</div>\r\n\r\n::: info \r\n加入群聊一起交流哦！如有错误的地方，欢迎指正！\r\n\r\n<ul>\r\n    <li><a target=\"_blank\" href=\"http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&k=_8OK2fsmwKYXliSoqszUCHZ_RnMmcZsm&authKey=KEju9D76HcqTr3vuFLbdkamaqpGVYcvfo%2F%2BlLd04GucOwH0XnMZjeg0a0WUJ7OwQ&noverify=0&group_code=961215331\">架构师：961215331</a></li>\r\n    <li><a target=\"_blank\" href=\"http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&k=1CRaLYPuesGlWXEPQmqwmi2UsTgXebSz&authKey=EReo0mUHRG9%2FGdYsRLClzizP%2BcRIzQCVIIHjfMLUmX%2FpoV4RIoAnQBktkimpKqdD&noverify=0&group_code=966469984\">操盘手：966469984</a></li>\r\n</ul>\r\n:::\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "感谢打赏"
    },
    "frontmatter": {
      "title": "感谢打赏",
      "date": "2025/03/05"
    },
    "type": "content"
  },
  {
    "title": "操盘手学习笔记",
    "path": "/docs/trader/trader.html",
    "url": "/docs/trader/trader.html",
    "content": "---\r\ntitle: 操盘手学习笔记\r\ndate: 2025/03/05\r\n---\r\n\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "操盘手学习笔记"
    },
    "frontmatter": {
      "title": "操盘手学习笔记",
      "date": "2025/03/05"
    },
    "type": "content"
  },
  {
    "title": "诗集",
    "path": "/docs/poetry/poetry.html",
    "url": "/docs/poetry/poetry.html",
    "content": "---\r\ntitle: 诗集\r\ndate: 2025/03/08\r\n---\r\n\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "诗集"
    },
    "frontmatter": {
      "title": "诗集",
      "date": "2025/03/08"
    },
    "type": "content"
  },
  {
    "title": "交易笔记",
    "path": "/docs/trading_journal/trading_journal.html",
    "url": "/docs/trading_journal/trading_journal.html",
    "content": "---\r\ntitle: 交易笔记\r\ndate: 2025/03/08\r\n---\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "交易笔记"
    },
    "frontmatter": {
      "title": "交易笔记",
      "date": "2025/03/08"
    },
    "type": "content"
  },
  {
    "title": "JAVA并发-设计模式",
    "path": "/docs/architect/concurrent/JAVAbingfa-shejimoshi.html",
    "url": "/docs/architect/concurrent/JAVAbingfa-shejimoshi.html",
    "content": "---\r\ntitle: JAVA并发-设计模式\r\ndate: 2025/04/22\r\n---\r\n\r\n- 终止线程的设计模式\r\n\t- Two-phase Termination（两阶段终止）模式：终止标志位\r\n- 避免共享的设计模式\r\n\t- Immutability模式：只读\r\n\t- Copy-on-Write模式：写时复制\r\n\t- Thread-Specific Storage 模式：线程本地存储 ThreadLocal\r\n- 多线程版本的 if 模式\r\n\t- Guarded Suspension 模式（Guarded Wait 模式、Spin Lock 模式）：一个线程需要等待另外的线程完成后继续下一步操作\r\n\t- Balking 模式：一个线程发现另一个线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回\r\n- 多线程分工模式\r\n\t- Thread-Per-Message 模式：为每个任务分配一个独立的线程\r\n\t- Worker Thread 模式：线程池\r\n\t- 生产者-消费者模式：核心是一个任务队列\r\n\t\t- 过饱问题：生产者生产的速度大于消费者消费的速度\r\n\t\t\t- 消费者每天能处理的量比生产者生产的少：消费者加机器\r\n\t\t\t- 消费者每天能处理的量比生产者生产的多：适当的加大队列\r\n\t\t\t- 系统高峰期生产者速度太快：生产者限流\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "JAVA并发-设计模式"
    },
    "frontmatter": {
      "title": "JAVA并发-设计模式",
      "date": "2025/04/22"
    },
    "type": "content"
  },
  {
    "title": "JVM-内存模型",
    "path": "/docs/architect/jvm/JVM-nacunmoxing.html",
    "url": "/docs/architect/jvm/JVM-nacunmoxing.html",
    "content": "---\r\ntitle: JVM-内存模型\r\ndate: 2025/03/04\r\n---\r\n\r\n::: tip 介绍\r\n1. JVM 内存模型\r\n2. JVM 内存核心参数\r\n3. 存调优案例\r\n:::\r\n\r\n## JVM 内存模型\r\n\r\n![JVM 内存模型](static/JVM-内存模型-内存模型.png)\r\n\r\n## JVM 内存核心参数\r\n\r\n![JVM 核心参数](static/JVM-内存模型-核心参数.png)\r\n\r\n- 关于元空间的JVM参数有两个：`-XX:MetaspaceSize=N` 和 `-XX:MaxMetaspaceSize=N`\r\n\t- `-XX:MaxMetaspaceSize` ： 设置元空间最大值， 默认是 -1， 即不限制， 或者说只受限于本地内存大小\r\n\t- `-XX:MetaspaceSize`： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发full gc进行类型卸载\r\n\t\t- 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过 `-XX:MaxMetaspaceSize`（如果设置了的话） 的情况下， 适当提高该值\r\n\t\t- 这个跟早期jdk版本的 `-XX:PermSize` 参数意思不一样，`-XX:PermSize` 代表永久代的初始容量\r\n\t- 由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将 MetaspaceSize 和 MaxMetaspaceSize 设置成一样的值，并设置得比初始值要大，对于 8G 物理内存的机器来说，一般我会将这两个值都设置为 256M\r\n- `-Xss` 设置越小，说明一个线程栈里能分配的栈帧就越少，但是对 JVM 整体来说能开启的线程数会更多\r\n- 尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收\r\n\r\n## 内存调优案例\r\n\r\n![JVM 内存调优案例](static/JVM-内存模型-案例.png)\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "JVM-内存模型",
      "lvl1": "JVM 内存模型",
      "lvl2": "JVM 内存核心参数",
      "lvl3": "内存调优案例"
    },
    "frontmatter": {
      "title": "JVM-内存模型",
      "date": "2025/03/04"
    },
    "type": "content"
  },
  {
    "title": "JVM-常量池",
    "path": "/docs/architect/jvm/JVM-changliangchi.html",
    "url": "/docs/architect/jvm/JVM-changliangchi.html",
    "content": "---\r\ntitle: JVM-常量池\r\ndate: 2025/03/04\r\n---\r\n\r\n::: tip 介绍\r\n1. Class 常量池与运行时常量池\r\n2. 字符串常量池\r\n3. 八种基本类型的包装类和对象池\r\n:::\r\n\r\n## Class 常量池与运行时常量池\r\n\r\n- Class 常量池与运行时常量池（`javap -v Xxx.class` -> Constant pool）：常量池中主要存放字面量和符号引用\r\n\t- Class常量池可以理解为是Class文件中的资源仓库\r\n\t\t- Class文件中除了包含类的版本、字段、方法、接口等描述信息外， 还有一项信息就是常量池(constant pool table)，用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic References)\r\n\t- 字面量：就是指由字母、数字等构成的字符串或者数值常量\r\n\t\t- 字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=1 这里的a为左值，1为右值\r\n\t- 符号引用：是编译原理中的概念，是相对于直接引用来说的\r\n\t\t- 主要包括了三类常量：类和接口的全限定名；字段的名称和描述符；方法的名称和描述符\r\n\t- 运行时常量池：这些常量池现在是静态信息，只有到运行时被加载到内存后，这些符号才有对应的内存地址信息，这些常量池一旦被装入内存就变成运行时常量池\r\n\t\t- 例如，compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的 地址，主要通过对象头里的类型指针去转换直接引用\r\n\r\n## 字符串常量池\r\n- 字符串常量池\r\n\t- 设计思想\r\n\t\t- 字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能\r\n\t\t- JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化\r\n\t\t\t- 为字符串开辟一个字符串常量池，类似于缓存区\r\n\t\t\t- 创建字符串常量时，首先查询字符串常量池是否存在该字符串\r\n\t\t\t- 存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中\r\n\t- 三种字符串操作\r\n\t\t- 直接赋值字符串（指向常量池中的引用）：`String s = \"jxch\";`\r\n\t\t\t- 这种方式创建的字符串对象，只会在常量池中\r\n\t\t\t- 创建对象s的时候，JVM会先去常量池中通过 equals(key) 方法，判断是否有相同的对象\r\n\t\t\t\t- 如果有，则直接返回该对象在常量池中的引用\r\n\t\t\t\t- 如果没有，则会在常量池中创建一个新对象，再返回引用\r\n\t\t- `String s = new String(\"jxch\");` （指向内存中的对象引用）\r\n\t\t\t- 这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用\r\n\t\t\t- 先检查字符串常量池中是否存在字符串\r\n\t\t\t\t- 不存在，先在字符串常量池里创建一个字符串对象；再去内存中创建一个字符串对象\r\n\t\t\t\t- 存在的话，就直接去堆内存中创建一个字符串对象\r\n\t\t\t- 最后，将内存中的引用返回\r\n\t\t- `intern` 方法是一个 native 的方法\r\n\t\t\t- 如果池已经包含一个等于此String对象的字符串（equals(oject)），则返回池中的字符串\r\n\t\t\t- 否则，将intern返回的引用指向当前字符串\r\n\t\t\t\t- 在 JDK 1.7 (及以上版本) 中，由于字符串池不在永久代了，intern() 做了一些修改，更方便地利用堆中的对象（字符串不存在时不再需要重新创建实例，可以直接指向堆上的实例）\r\n\t\t\t\t- jdk1.6版本需要将字符串复制到字符串常量池里\r\n\t- 常量池的位置\r\n\t\t- Jdk1.6及之前： 有永久代, 运行时常量池在永久代，运行时常量池包含字符串常量池\r\n\t\t- Jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池从永久代里的运行时常量池分离到堆里\r\n\t\t- Jdk1.8及之后： 无永久代，运行时常量池在元空间，字符串常量池里依然在堆里\r\n\t- 设计原理：类似 HashTable ，本质上是字符串对象的引用\r\n\r\n## 八种基本类型的包装类和对象池\r\n- 八种基本类型的包装类和对象池\r\n\t- java中基本类型的包装类的大部分都实现了常量池技术 (严格来说应该叫对象池，在堆上)\r\n\t- Byte,Short,Integer,Long,Character,Boolean （另外两种浮点数类型的包装类则没有实现对象池）\r\n\t- Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池\r\n\t\t- 即对象不负责创建和管理大于127的这些类的对象\r\n\t\t- 一般这种比较小的数用到的概率相对较大\r\n\r\n\r\n## 字符串常量池示例\r\n\r\n```java\r\nString s1 = new String(\"he\") + new String(\"llo\");\r\nString s2 = s1.intern();\r\n \r\nSystem.out.println(s1 == s2);\r\n// 在 JDK 1.6 下输出是 false，创建了 6 个对象\r\n// 在 JDK 1.7 及以上的版本输出是 true，创建了 5 个对象 \r\n// 当然我们这里没有考虑GC，但这些对象确实存在或存在过\r\n```\r\n\r\n![字符串常量池-JDK1.7+](static/JVM-常量池-字符串常量池-JDK1.7+.png)\r\n\r\n\r\n![字符串常量池-JDK1.6](static/JVM-常量池-字符串常量池-JDK1.6.png)\r\n\r\n```java\r\nString s0=\"zhuge\"; \r\nString s1=\"zhuge\"; \r\nString s2=\"zhu\" + \"ge\";\r\nSystem.out.println( s0==s1 ); //true \r\nSystem.out.println( s0==s2 ); //true\r\n\r\nString s0=\"zhuge\";\r\nString s1=new String(\"zhuge\");\r\nString s2=\"zhu\" + new String(\"ge\");\r\nSystem.out.println( s0==s1 ); // false \r\nSystem.out.println( s0==s2 )； // false \r\nSystem.out.println( s1==s2 ); // false\r\n\r\nString a = \"a1\";\r\nString b = \"a\" + 1;\r\nSystem.out.println(a == b); // true\r\nString a = \"atrue\";\r\nString b = \"a\" + \"true\";\r\nSystem.out.println(a == b); // true\r\nString a = \"a3.4\";\r\nString b = \"a\" + 3.4;\r\nSystem.out.println(a == b); // true\r\n\r\nString a = \"ab\"; \r\nString bb = \"b\"; \r\nString b = \"a\" + bb;\r\nSystem.out.println(a == b); // false 由于在字符串的\"+\"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的\r\n\r\nString a = \"ab\";\r\nfinal String bb = \"b\"; \r\nString b = \"a\" + bb;\r\nSystem.out.println(a == b); // true 对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中\r\n\r\nprivate static String getBB() { return \"b\"; }\r\nString a = \"ab\";\r\nfinal String bb = getBB(); \r\nString b = \"a\" + bb;\r\nSystem.out.println(a == b); // false JVM对于字符串引用bb，它的值在编译期无法确定，只能在程序运行期调用方法后，将方法的返回值和\"a\"来动态连接并分配地址为b\r\n\r\nString str1 = new StringBuilder(\"ja\").append(\"va\").toString();\r\nSystem.out.println(str1 == str1.intern()); //false java是关键字，在JVM初始化的相关类里肯定早就放进字符串常量池了\r\n```\r\n\r\n::: info 注意\r\nString是不可变的\r\n:::\r\n\r\n```java\r\nString s = \"a\" + \"b\" + \"c\"; //就等价于String s = \"abc\";\r\nString a = \"a\";\r\nString b = \"b\";\r\nString c = \"c\";\r\nString s1 = a + b + c;\r\n\r\n// `s1` 这个就不一样了，可以通过观察其 `JVM` 指令码发现 `s1` 的 `+` 操作会变成如下操作\r\nStringBuilder temp = new StringBuilder(); \r\ntemp.append(a).append(b).append(c);\r\nString s = temp.toString();\r\n```\r\n\r\n## 包装类对象池示例\r\n\r\n```java\r\n //5种整形的包装类Byte,Short,Integer,Long,Character的对象，\r\n //在值小于127时可以使用对象池\r\n Integer i1 = 127; //这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池 \r\n Integer i2 = 127;\r\n System.out.println(i1 == i2);//输出true\r\n \r\n //值大于127时，不会从对象池中取对象\r\n Integer i3 = 128;\r\n Integer i4 = 128;\r\n System.out.println(i3 == i4);//输出false\r\n \r\n //用new关键词新生成对象不会使用对象池\r\n Integer i5 = new Integer(127);\r\n Integer i6 = new Integer(127);\r\n System.out.println(i5 == i6);//输出false\r\n \r\n //Boolean类也实现了对象池技术\r\n Boolean bool1 = true;\r\n Boolean bool2 = true;\r\n System.out.println(bool1 == bool2);//输出true\r\n \r\n //浮点类型的包装类没有实现对象池技术\r\n Double d1 = 1.0;\r\n Double d2 = 1.0;\r\n System.out.println(d1 == d2);//输出false\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "JVM-常量池",
      "lvl1": "Class 常量池与运行时常量池",
      "lvl2": "字符串常量池",
      "lvl3": "八种基本类型的包装类和对象池",
      "lvl4": "字符串常量池示例",
      "lvl5": "包装类对象池示例"
    },
    "frontmatter": {
      "title": "JVM-常量池",
      "date": "2025/03/04"
    },
    "type": "content"
  },
  {
    "title": "Redis-持久化",
    "path": "/docs/architect/redis/Redis-chijiuhua.html",
    "url": "/docs/architect/redis/Redis-chijiuhua.html",
    "content": "---\r\ntitle: Redis-持久化\r\ndate: 2025/03/05\r\n---\r\n\r\n::: tip 介绍\r\n1. RDB：dump.rdb （二进制文件）\r\n2. AOF（append-only file）：appendonly.aof（resp协议格式）\r\n3. 混合持久化：RDB+AOF\r\n4. 数据备份策略\r\n:::\r\n\r\n## RDB: dump.rdb\r\n\r\n- RDB：dump.rdb （二进制文件）\r\n\t- 配置文件：`bgsave` 方式\r\n\t\t- `save 60 1000`  关闭RDB只需要将所有的 `save` 保存策略注释掉即可\r\n\t\t\t- 60 秒内有至少有 1000 个键被改动， 则进行一次 RDB 持久化\r\n\t- 命令：覆盖原有 rdb 快照文件\r\n\t\t- `save`：同步\r\n\t\t- `bgsave`：异步，写时复制 - COW机制\r\n\t\t\t- `bgsave` 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据\r\n\t\t\t\t- 在生成子进程执行调用fork函数时会有短暂阻塞\r\n\t\t\t- 如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，`bgsave` 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据\r\n\r\n::: danger 缺点\r\n宕机后，服务器将丢失最近写入、且仍未保存到快照中的数据\r\n:::\r\n\r\n## AOF: appendonly.aof\r\n\r\n- AOF（append-only file）：appendonly.aof（resp协议格式）\r\n\t- 将修改的每一条指令记录进文件appendonly.aof中（先写入os cache，每隔一段时间fsync到磁盘）\r\n\t- 命令：`bgrewriteaof`  （fork出一个子进程去做）\r\n\t- 配置文件\r\n\r\n|配置文件|介绍|\r\n|-|-|\r\n|`appendonly yes`|开启AOF模式|\r\n|`appendfsync always`|每条命令都fsync一次，拉低性能|\r\n|`appendfsync everysec`|每秒fsync一次，推荐，缺点是宕机后会丢失1秒的数据，但可以从数据库恢复|\r\n|`appendfsync no`|让操作系统决定fsync的时机，快但不安全|\r\n|`auto‐aof‐rewrite‐min‐size 64mb`|AOF文件超过64M时，重写AOF文件（整合命令）|\r\n|`auto‐aof‐rewrite‐percentage 100`|自上一次重写后文件大小增长了100%则再次触发重写|\r\n\r\n::: warning 缺点\r\n体积大，恢复慢\r\n:::\r\n\r\n## 混合持久化\r\n\r\n- 混合持久化：RDB+AOF\r\n\t- 配置文件（必须先开启AOF）：`aof‐use‐rdb‐preamble yes`\r\n\t- 将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令（生成RDB过程中产生的命令）存在一起，都写入新的AOF文件\r\n\t- 新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换\r\n\r\n::: info 优点\r\n在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的AOF 全量文件重放，因此重启效率大幅得到提升\r\n:::\r\n\r\n![混合持久化](static/Redis-持久化-appendonly.aof.png)\r\n\r\n## 数据备份策略\r\n\r\n- 数据备份策略：\r\n\t1. 写crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48小时的备份\r\n\t2. 每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份\r\n\t3. 每次copy备份的时候，删除一些旧备份\r\n\t4. 每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "Redis-持久化",
      "lvl1": "RDB: dump.rdb",
      "lvl2": "AOF: appendonly.aof",
      "lvl3": "混合持久化",
      "lvl4": "数据备份策略"
    },
    "frontmatter": {
      "title": "Redis-持久化",
      "date": "2025/03/05"
    },
    "type": "content"
  },
  {
    "title": "2025-03",
    "path": "/docs/diary/2025/2025-03.html",
    "url": "/docs/diary/2025/2025-03.html",
    "content": "---\r\ntitle: 2025-03\r\npassword: b593bf97f44387eb6fdc629acef2d138\r\ndate: 2025/03/08\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 2025-03-08\r\n\r\n- 优化博客站点\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "2025-03",
      "lvl1": "2025-03-08"
    },
    "frontmatter": {
      "title": "2025-03",
      "password": "b593bf97f44387eb6fdc629acef2d138",
      "date": "2025/03/08"
    },
    "type": "content"
  },
  {
    "title": "边缘填充算法",
    "path": "/docs/it/jisuanjituxingxue/bianyuantianchongsuanfa.html",
    "url": "/docs/it/jisuanjituxingxue/bianyuantianchongsuanfa.html",
    "content": "---\r\ntitle: 边缘填充算法\r\ndate: 2025/03/08\r\n---\r\n\r\n## 填充原理\r\n边缘填充算法是先求出多边形的每条边与扫描线的交点，然后**将交点右侧的所有像素颜色全部取为补色（或反色**）。按任意顺序处理完多边形的所有边后，就完成了多边形的填充任务。边缘填充算法利用了图像处理中的求“补”或求“反”的概念，对于黑白图像，求补就是把RGB(1,1,1)（白色）的像素置为RGB(0,0,0)（黑色），反之亦然；对于彩色图像，求补就是将背景色置为填充色，反之亦然。求补的一条基本性质是**一个像素求补两次就恢复为原色**。**如果多边形内部的像素被求补偶数次，保持原色，如果被求补奇数次，显示填充色。**\r\n\r\n## 填充过程\r\n假定边的顺序为E0、E1、E2、E3、E4、E5和E6。这里，边的顺序并不影响填充结果，只是方便编写循环结构而已。\r\n\r\n\r\n![边缘填充算法](static/边缘填充算法.png)\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "边缘填充算法",
      "lvl1": "填充原理",
      "lvl2": "填充过程"
    },
    "frontmatter": {
      "title": "边缘填充算法",
      "date": "2025/03/08"
    },
    "type": "content"
  },
  {
    "title": "期权交易策略",
    "path": "/docs/trader/options/qiquanjiaoyicelue.html",
    "url": "/docs/trader/options/qiquanjiaoyicelue.html",
    "content": "---\r\ntitle: 期权交易策略\r\ndate: 2025/03/06\r\n---\r\n\r\n## 单向策略\r\n\r\n::: tip\r\n|评估|Long Call|Long Put|Short Call|Short Put|\r\n|-|-|-|-|-|\r\n|预期|上涨|下跌|微涨/不变|微跌/不变/有买入意愿|\r\n|场景|看涨|看跌|赚权利金|赚权利金/低价买入|\r\n|权利|按行权价买入|按行权价卖出|-|-|\r\n|义务|-|-|按行权价卖出|按行权价买入|\r\n|成本|权利金|权利金|保证金|保证金|\r\n|收益|涨幅 - 权利金|跌幅 - 权利金|权利金 - (市价 - 行权价)|权利金 - (行权价 - 市价)|\r\n|亏损|损失权利金|损失权利金|越涨越亏|越跌越亏 （最低为0）|\r\n|风险|风险低；收益无限|风险低；收益高|风险无限；收益低|风险高；收益低|\r\n\r\n::: danger\r\n1. 卖方的最大成本取决于市场的波动性，虽然表格中用“保证金”表示，但实际计算中，卖方承担的亏损可能远超保证金。\r\n:::\r\n\r\n\r\n- 买入看涨期权：Long Call\r\n  - 预期：标的资产价格将上涨\r\n  - 权利：买方有权利在期权到期时按行权价买入标的资产，但没有义务。\r\n  - 成本：买方需要支付权利金。\r\n  - 收益：潜在收益是无限的（标的资产价格上涨越多，收益越大）。\r\n  - 风险：风险有限，最大损失是支付的权利金。\r\n- 买入看跌期权：Long Put\r\n  - 预期：标的资产价格将下跌\r\n  - 权利：买方有权利在期权到期时按行权价卖出标的资产，但没有义务。\r\n  - 成本：买方需要支付权利金。\r\n  - 收益：潜在收益有限，但标的资产价格跌得越多，收益越大（最低价格为0）。\r\n  - 风险：风险有限，最大损失是支付的权利金。\r\n- 卖出看涨期权：Short Call\r\n  - 预期：标的资产价格不会上涨太多或保持不变\r\n  - 义务：卖方有义务按行权价卖出标的资产给买方（如果买方行权）。\r\n  - 收益：收益有限，最大收益是收到的权利金。\r\n  - 风险：风险无限（标的资产价格上涨越多，卖方亏损越大）。\r\n- 卖出看跌期权：Short Put\r\n  - 预期：标的资产价格不会大幅下跌或保持不变\r\n  - 义务：卖方有义务按行权价买入标的资产（如果买方行权）。\r\n  - 收益：收益有限，最大收益是收到的权利金。\r\n  - 风险：风险很高（标的资产价格下跌越多，卖方亏损越大，但跌幅有限，最低为0）。\r\n\r\n\r\n## 价差策略\r\n\r\n::: tip\r\n|评估|Bull Spread|Bear Spread|\r\n|-|-|-|\r\n|预期|温和上涨|温和下跌|\r\n|场景|在看涨市场中降低成本|在看跌市场中降低成本|\r\n|收益|行权价差 - 净权利金|行权价差 - 净权利金|\r\n|成本|净权利金|净权利金|\r\n|亏损|净权利金|净权利金|\r\n|风险|风险低；收益低|风险低；收益低|\r\n|构成|买入较低行权价的看涨期权 <br/> 卖出较高行权价的看涨期权|买入较高行权价的看跌期权 <br/> 卖出较低行权价的看跌期权|\r\n\r\n::: info\r\n1. 如果标的价格超出价格区间以外，那么期权的权利与义务会互相抵消，所以限制了最大收益，同时也限制了最大亏损\r\n2. Bull Spread 和 Bear Spread 都是低风险、低收益的策略，适合温和的市场走势，而非剧烈波动\r\n:::\r\n\r\n- 牛市价差：Bull Spread\r\n  - 预期：适用于看涨市场，收益和风险都有限\r\n  - 构成：\r\n    - 买入较低行权价的看涨期权（成本较高）\r\n    - 卖出较高行权价的看涨期权（获得权利金）\r\n  - 收益风险：\r\n    - 最大收益：两行权价差 - 净支出\r\n    - 最大亏损：净支出（买入权利金 - 卖出权利金）\r\n- 熊市价差：Bear Spread\r\n  - 预期：适用于看跌市场，收益和风险都有限\r\n  - 构成：\r\n    - 买入较高行权价的看跌期权（成本较高）\r\n    - 卖出较低行权价的看跌期权（获得权利金）\r\n  - 收益风险：\r\n    - 最大收益：两行权价差 - 净支出\r\n    - 最大亏损：净支出（买入权利金 - 卖出权利金）\r\n\r\n\r\n### 跨式策略\r\n\r\n::: tip\r\n|评估|Long Straddle|Long Strangle|Short Straddle|Short Strangle|\r\n|-|-|-|-|-|\r\n|预期|大幅波动|大幅波动|||\r\n|场景|重大事件前|重大事件前|||\r\n|收益|波幅 - 净权利金|波幅 - 净权利金|||\r\n|成本|净权利金|净权利金|||\r\n|亏损|净权利金|净权利金|||\r\n|风险|风险低；收益高|风险低；收益高；成本低|||\r\n|构成|买入相同行权价的看涨期权 <br/> 买入相同行权价的看跌期权|买入较高行权价的看涨期权 <br/> 买入较低行权价的看跌期权|||\r\n:::\r\n\r\n\r\n\r\n\r\n### 复杂价差策略\r\n\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "期权交易策略",
      "lvl1": "单向策略",
      "lvl2": "价差策略"
    },
    "frontmatter": {
      "title": "期权交易策略",
      "date": "2025/03/06"
    },
    "type": "content"
  },
  {
    "title": "期权交易策略收益图表",
    "path": "/docs/trader/options/qiquanjiaoyicelueshouyitubiao.html",
    "url": "/docs/trader/options/qiquanjiaoyicelueshouyitubiao.html",
    "content": "---\r\ntitle: 期权交易策略收益图表\r\ndate: 2025/03/08\r\n---\r\n\r\n<iframe src=\"/html/OptionsStrategy.html\" style=\"width:100%; height: 1000px\"></iframe>\r\n\r\n<a href=\"/html/OptionsStrategy.html\" target=\"_blank\">全屏展示</a>\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "期权交易策略收益图表"
    },
    "frontmatter": {
      "title": "期权交易策略收益图表",
      "date": "2025/03/08"
    },
    "type": "content"
  },
  {
    "title": "实盘日记 - 2025 年",
    "path": "/docs/trading_journal/diary/2025.html",
    "url": "/docs/trading_journal/diary/2025.html",
    "content": "---\r\ntitle: 实盘日记 - 2025 年\r\ndate: 2025/03/19\r\n---\r\n\r\n## 2025/3/19 TQQQ CALL\r\n\r\n:::info\r\n- 策略类型：看涨期权（短期反弹博弈）\r\n- 期权类型：买入TQQQ Call期权\r\n- 行权价：61-62美元附近\r\n- 到期日：2-4周\r\n- 仓位：500美元以内\r\n- 止盈目标：EMA20（68美元附近）\r\n- 止损位：57美元以下\r\n\r\n|情境|股价目标|期权预估价值|盈亏金额|盈亏百分比|\r\n|-|-|-|-|-|\r\n|止盈|68美元|约6.2美元|盈利740美元|+148%|\t\t\t\t\r\n|止损|57美元|约0.8美元|亏损340美元|-68%|\r\n\r\n盈亏比大于2，属于较好的盈亏比\r\n:::\r\n\r\n预计收益计算（止盈情境）：假设未来1-2周内TQQQ上涨到EMA20附近（约68美元）\r\n- 行权价：62美元\r\n- 股价上涨到：68美元\r\n- 期权的内在价值 = 股票价格 – 行权价格 = 68 – 62 = 6美元\r\n- 期权买入成本：2.5美元/张\r\n- 期权到期时预估的价值：6美元（内在价值）+ 0.2美元左右的时间价值估计（由于临近到期，时间价值不多）= 约6.2美元\r\n- 每张期权盈利 = 6.2美元 - 2.5美元 = 3.7美元\r\n- 2张期权总盈利 = 3.7美元 × 2张 × 100股 = 740美元\r\n\r\n止盈情境下的收益率：\r\n- 总盈利 = 740美元\r\n- 总成本 = 500美元\r\n- 净利润 = 740美元\r\n- 盈利比例 = (740 ÷ 500) × 100% = 148%\r\n\r\n预计亏损计算（止损情境）：假设未来几天内TQQQ下跌到57美元以下\r\n- 行权价：62美元（看涨期权）\r\n- 跌破支撑位到57美元甚至更低，此时期权变为深度价外，价值快速缩水。\r\n- 假设跌破57美元时，看涨期权的价值大幅缩水到0.8美元左右（甚至更低），此时及时止损：\r\n- 每张期权亏损 = 买入成本 - 期权剩余价值 = 2.5美元 - 0.8美元 = 1.7美元\r\n- 2张期权总亏损 = 1.7美元 × 2张 × 100股 = 340美元\r\n\r\n止损情境下的亏损率：\r\n- 总亏损 = 340美元\r\n- 总成本 = 500美元\r\n- 亏损比例 = (340 ÷ 500) × 100% = 68%\r\n\r\n盈亏比评估：盈亏比大于2，属于较好的盈亏比\r\n- 盈利情境预期盈利 = 740美元\r\n- 亏损情境预期亏损 = 340美元\r\n- 盈亏比 = 740 ÷ 340 ≈ 2.18\r\n\r\n\r\n\r\n",
    "lang": "zh-CN",
    "hierarchy": {
      "lvl0": "实盘日记 - 2025 年",
      "lvl1": "2025/3/19 TQQQ CALL"
    },
    "frontmatter": {
      "title": "实盘日记 - 2025 年",
      "date": "2025/03/19"
    },
    "type": "content"
  }
]